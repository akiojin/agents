import EventEmitter from 'events';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import type { Config, ChatMessage, TaskConfig, TaskResult } from '../config/types.js';
import { logger, PerformanceLogger, LogLevel } from '../utils/logger.js';
import { withRetry } from '../utils/retry.js';
import type { LLMProvider } from '../providers/base.js';
import { createProviderFromUnifiedConfig } from '../providers/factory.js';
import { TaskExecutor } from './task-executor.js';
import { MemoryManager } from './memory.js';
import { MCPToolsHelper, MCPTaskPlanner } from '../mcp/tools.js';
import type { MCPManager } from '../mcp/manager.js';
import { MCPFunctionConverter, type FunctionDefinition } from '../mcp/function-converter.js';

import { SimpleTaskDecomposer } from './task-decomposer.js';
import { ParallelExecutor } from './parallel-executor.js';

// ContinuousExecutionEngine„ÅÆAgentCore„Å∏„ÅÆÈùôÁöÑ„Éó„É≠„Éë„ÉÜ„Ç£ËøΩÂä†Áî®
interface AgentCoreStatic {
  ContinuousExecutionEngine: typeof ContinuousExecutionEngine;
}

export class AgentCore extends EventEmitter {
  private config: Config;
  private provider: LLMProvider;
  private taskExecutor: TaskExecutor;
  private memoryManager: MemoryManager;
  private mcpToolsHelper?: MCPToolsHelper;
  private mcpTaskPlanner?: MCPTaskPlanner;
  private mcpFunctionConverter?: MCPFunctionConverter;
  private availableFunctions: FunctionDefinition[] = [];
  private taskDecomposer: SimpleTaskDecomposer;
  private parallelExecutor: ParallelExecutor;
  private history: ChatMessage[] = [];
  private currentModel: string;
  private parallelMode: boolean = false;
  private verboseMode: boolean = false;
  
  // Memory management configuration
  private readonly MAX_HISTORY_SIZE = 100; // Maximum history size
  private readonly MEMORY_CHECK_INTERVAL = 10; // Check memory every N chats
  private chatCount: number = 0; // Chat count
  
  // Resource management
  private timers: Set<NodeJS.Timeout> = new Set();
  private eventListeners: WeakMap<object, Function[]> = new WeakMap();

  constructor(config: Config, continueSession: boolean = false) {
    super();
    this.config = config;
    this.currentModel = config.llm.model || this.getDefaultModel();
    this.provider = createProviderFromUnifiedConfig(config);
    this.taskExecutor = new TaskExecutor(this.convertToLegacyConfig(config));
    this.memoryManager = new MemoryManager(config.paths.history);
    this.taskDecomposer = new SimpleTaskDecomposer();
    this.parallelExecutor = new ParallelExecutor(config.app.maxParallel || 3);
    
    // Initialize asynchronously (with error handling)
    void this.initialize(continueSession);
    
    // Register cleanup handlers for process exit
    this.setupCleanupHandlers();
  }

  /**
   * Convert new Config type to legacy Config type
   */
  private convertToLegacyConfig(config: Config): import('../types/config.js').Config {
    return {
      provider: config.llm.provider,
      apiKey: config.llm.apiKey,
      model: config.llm.model,
      localEndpoint: config.localEndpoint,
      useMCP: config.mcp.enabled,
      mcpServers: config.mcp.servers,
      maxParallel: config.app.maxParallel,
      timeout: config.app.timeout,
      logLevel: config.app.logLevel,
      cachePath: config.paths.cache,
      historyPath: config.paths.history,
    };
  }

  private async initialize(continueSession: boolean = false): Promise<void> {
    try {
      // Load history„ÅÆË™≠„ÅøËæº„Åø„ÅØ„Çª„ÉÉ„Ç∑„Éß„É≥Á∂ôÁ∂ö„Éï„É©„Ç∞„Å´„Çà„Å£„Å¶Âà∂Âæ°
      if (continueSession) {
        this.history = await this.memoryManager.loadHistory();
        console.log(`üìÇ Previous session loaded (${this.history.length} messages)`);
        logger.info('Previous session loaded');
      } else {
        this.history = [];
        console.log('üÜï New session started');
        logger.info('New session started');
      }
      
      // Optimize memory on startup
      await this.optimizeMemory();
      
      // logger.info('Agent core initialized');
    } catch (error) {
      logger.error('InitializeError:', error);

      // Basic functionality remains available even with initialization error
      this.history = [];
      if (continueSession) {
        logger.warn('Failed to load history, starting as new session instead');
      } else {
        logger.info('New session started');
      }

      // Initialization error is not fatal, so don't throw exception
    }
  }

  /**
   * Configure cleanup handlers
   */
  private setupCleanupHandlers(): void {
    const cleanup = () => {
      this.cleanup();
    };

    // Cleanup on process exit
    process.on('exit', cleanup);
    process.on('SIGINT', cleanup);
    process.on('SIGTERM', cleanup);
    process.on('uncaughtException', (error) => {
      logger.error('Uncaught exception:', error);
      cleanup();
      process.exit(1);
    });
  }

  /**
   * Clean up resources
   */
  public cleanup(): void {
    try {
      // Clear timers
      this.timers.forEach(timer => clearTimeout(timer));
      this.timers.clear();

      // Remove event listeners
      this.removeAllListeners();

      logger.info('Resource cleanup completed');
    } catch (error) {
      logger.error('CleanupError:', error);
    }
  }

  /**
   * Memory optimization processing
   */
  private async optimizeMemory(): Promise<void> {
    try {
      // Limit history size
      if (this.history.length > this.MAX_HISTORY_SIZE) {
        const oldSize = this.history.length;
        this.history = this.history.slice(-this.MAX_HISTORY_SIZE);
        await this.memoryManager.saveHistory(this.history);
        logger.info(`History optimized: ${oldSize} items ‚Üí ${this.history.length} items`);
      }

      // Also optimize MemoryManager history
      await this.memoryManager.pruneHistory(this.MAX_HISTORY_SIZE);

      // Execute garbage collection (if available)
      if (global.gc) {
        global.gc();
        logger.debug('Garbage collection executed');
      }
    } catch (error) {
      logger.error('Memory optimization error:', error);
    }
  }

  /**
   * Monitor memory usage
   */
  private monitorMemoryUsage(): void {
    const memUsage = process.memoryUsage();
    const mbUsage = {
      rss: Math.round(memUsage.rss / 1024 / 1024),
      heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
      heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
      external: Math.round(memUsage.external / 1024 / 1024),
    };

    logger.debug('Memory usage:', mbUsage);

    // Warning when memory usage is high
    if (mbUsage.heapUsed > 500) { // When over 500MB
      logger.warn(`Memory usage is high: ${mbUsage.heapUsed}MB`);
      // Execute automatic optimization
      void this.optimizeMemory();
    }
  }

  /**
   * Register timer (with automatic cleanup)
   */
  private registerTimer(callback: () => void, delay: number): NodeJS.Timeout {
    const timer = setTimeout(() => {
      this.timers.delete(timer);
      callback();
    }, delay);
    
    this.timers.add(timer);
    return timer;
  }

  private getDefaultModel(): string {
    switch (this.config.llm.provider) {
      case 'openai':
        return 'gpt-4-turbo-preview';
      case 'anthropic':
        return 'claude-3-opus-20240229';
      case 'local-gptoss':
      case 'local-lmstudio':
        return 'local-model';
      default:
        return 'gpt-4';
    }
  }

  async chat(input: string): Promise<string> {
    const perf = new PerformanceLogger('chat');
    const { globalProgressReporter } = await import('../ui/progress.js');

    try {
      // „Éó„É≠„Ç∞„É¨„ÇπË°®Á§∫Started
      globalProgressReporter.startTask('Chat processing', ['Input validation', 'MCP check', 'LLM call', 'Response processing', 'History save']);

      // ÂÖ•ÂäõValidation
      globalProgressReporter.updateSubtask(0);
      if (!input || input.trim().length === 0) {
        globalProgressReporter.completeTask(false);
        throw new Error('Input is empty');
      }

      const trimmedInput = input.trim();
      if (trimmedInput.length > 32000) {
        globalProgressReporter.completeTask(false);
        throw new Error('Input is too long (maximum 32,000 characters)');
      }

      // Function CallingÊ∫ñÂÇô
      globalProgressReporter.updateSubtask(1);

      // „É°„É¢„É™‰ΩøÁî®Èáè„ÉÅ„Çß„ÉÉ„ÇØÔºàÂÆöÊúüÁöÑÔºâ
      this.chatCount++;
      if (this.chatCount % this.MEMORY_CHECK_INTERVAL === 0) {
        this.monitorMemoryUsage();
        await this.optimizeMemory();
      }

      // UserMessage„ÇíHistory„Å´ËøΩÂä†
      const userMessage: ChatMessage = {
        role: 'user',
        content: trimmedInput,
        timestamp: new Date(),
      };
      this.history.push(userMessage);

      // ProviderConnectionCheck
      if (!this.provider) {
        globalProgressReporter.completeTask(false);
        throw new Error('LLM Provider not initialized');
      }

      // LLMÂëº„Å≥Âá∫„Åó
      globalProgressReporter.updateSubtask(2);
      
      // Mock mode check
      let result;
      if (process.env.MOCK_LLM_RESPONSE === 'true') {
        // Return mock response for testing
        result = {
          success: true,
          result: {
            content: `Mock response to: "${trimmedInput}". This is a test response for REPL debugging.`,
            usage: {
              promptTokens: 10,
              completionTokens: 15,
              totalTokens: 25
            },
            functionCall: undefined
          }
        };
      } else {
        // withRetry„Çí‰ΩøÁî®„Åó„ÅüLLMÂëº„Å≥Âá∫„ÅóÔºàFunction CallingÂØæÂøúÔºâ
        result = await withRetry(
          async () => {
            const chatOptions = {
              model: this.currentModel,
              temperature: this.config.llm.temperature || 0.7,
              maxTokens: this.config.llm.maxTokens || 2000,
              tools: this.availableFunctions.length > 0 ? this.availableFunctions : undefined,
              tool_choice: this.availableFunctions.length > 0 ? 'auto' as const : undefined
            };
            
            // GPT-OSS„ÅØÂº∑Âà∂„ÉÑ„Éº„É´ÊåáÂÆö„Çí„Çµ„Éù„Éº„Éà„Åó„Å™„ÅÑ„Åü„ÇÅauto„ÅÆ„Åø‰ΩøÁî®
            // ‰ª£„Çè„Çä„Å´serena„ÉÑ„Éº„É´„Çí‰∏ä‰Ωç„Å´ÈÖçÁΩÆ„Åó„Å¶ÂÑ™ÂÖàÂ∫¶„Çí‰∏ä„Åí„Çã
            if (chatOptions.tools && chatOptions.tools.length > 0) {
              if (input.includes('„Éá„Ç£„É¨„ÇØ„Éà„É™') || input.includes('„Éï„Ç°„Ç§„É´‰∏ÄË¶ß') || input.includes('ÊßãÈÄ†') || input.includes('Ëß£Êûê')) {
                // serena„ÉÑ„Éº„É´„ÇíÈÖçÂàó„ÅÆÂÖàÈ†≠„Å´ÁßªÂãï
                const serenaTools = chatOptions.tools.filter(t => t.name.startsWith('serena_'));
                const otherTools = chatOptions.tools.filter(t => !t.name.startsWith('serena_'));
                chatOptions.tools = [...serenaTools, ...otherTools];
                logger.debug('Prioritized serena tools for directory analysis');
              }
            }
            
            // Function Calling„ÅÆÁä∂ÊÖã„Çí„É≠„Ç∞„Å´Ë®òÈå≤
            if (this.availableFunctions.length > 0) {
              logger.debug(`Function Calling enabled: ${this.availableFunctions.length} functions available`);
            } else {
              logger.debug('Function Calling disabled: No functions available');
            }
            
            logger.debug('Chat request with function calling', {
              toolsCount: this.availableFunctions.length,
              hasTools: !!chatOptions.tools
            });
            
            const response = await this.provider.chat(this.history, chatOptions);
            
            // LLM„É¨„Çπ„Éù„É≥„Çπ„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
            logger.debug('LLM Response type:', typeof response);
            if (typeof response === 'object' && response !== null) {
              logger.debug('Response object keys:', Object.keys(response));
              if ('tool_calls' in response) {
                logger.debug('Tool calls detected:', response.tool_calls);
              }
            }
            
            return response;
          },
          {
            maxRetries: this.config.llm.maxRetries,
            delay: 1000,
            exponentialBackoff: true,
            timeout: this.config.llm.timeout,
            shouldRetry: (error: Error) => {
              const message = error.message.toLowerCase();
              // RetryÂèØËÉΩ„Å™Error: Timeout„ÄÅRate limit„ÄÅ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØError„ÄÅServerError
              return (
                message.includes('timeout') ||
                message.includes('rate limit') ||
                message.includes('too many requests') ||
                message.includes('network') ||
                message.includes('connection') ||
                message.includes('server error') ||
                message.includes('temporary') ||
                message.includes('service unavailable')
              );
            },
          },
        );
      }

      if (!result.success) {
        logger.error('LLMChatError after retries:', result.error);
        globalProgressReporter.completeTask(false);
        throw result.error!;
      }

      const llmResponse = result.result!;

      // ResponseProcessing
      globalProgressReporter.updateSubtask(3);

      // Function Calling„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
      if (llmResponse.functionCall || (llmResponse.tool_calls && llmResponse.tool_calls.length > 0)) {
        logger.info('Function call detected:', llmResponse.functionCall || llmResponse.tool_calls);
        
        // ToolÂëº„Å≥Âá∫„Åó„ÇíExecute - Êñ∞„Åó„ÅÑÂΩ¢Âºè„Å®Âè§„ÅÑÂΩ¢Âºè„ÅÆ‰∏°Êñπ„Å´ÂØæÂøú
        let toolCalls;
        if (llmResponse.tool_calls && llmResponse.tool_calls.length > 0) {
          // Êñ∞„Åó„ÅÑÂΩ¢ÂºèÔºàlocal.ts„Åã„ÇâÔºâ
          toolCalls = llmResponse.tool_calls.map(call => ({
            function: {
              name: call.function?.name || call.name,
              arguments: typeof call.function?.arguments === 'string' 
                ? call.function.arguments 
                : JSON.stringify(call.function?.arguments || call.arguments || {})
            }
          }));
        } else {
          // Âè§„ÅÑÂΩ¢Âºè
          toolCalls = Array.isArray(llmResponse.functionCall) 
            ? llmResponse.functionCall 
            : [llmResponse.functionCall];
        }
        
        const toolResults: string[] = [];
        
        for (const toolCall of toolCalls) {
          logger.info(`Executing tool: ${toolCall.function.name}`);
          
          try {
            // MCP„ÉÑ„Éº„É´„ÅÆÂàùÊúüÂåñ„ÉÅ„Çß„ÉÉ„ÇØ
            if (!this.mcpToolsHelper) {
              throw new Error('MCP tools not initialized yet. Please wait for initialization to complete.');
            }
            
            // ToolÂëº„Å≥Âá∫„Åó
            const toolResult = await this.mcpToolsHelper.executeTool(
              toolCall.function.name,
              toolCall.function.arguments ? JSON.parse(toolCall.function.arguments) : {}
            );
            
            toolResults.push(`Tool ${toolCall.function.name} result: ${JSON.stringify(toolResult)}`);
            
            // Tool result„ÇíÁµêÊûú„Å´Âê´„ÇÅ„Çã„Åå„ÄÅÂ±•Ê≠¥„Å´„ÅØËøΩÂä†„Åó„Å™„ÅÑÔºàÂæå„Åß„Åæ„Å®„ÇÅ„Å¶ËøΩÂä†Ôºâ

          } catch (error) {
            const errorMessage = `Tool ${toolCall.function.name} failed: ${error instanceof Error ? error.message : String(error)}`;
            logger.error(errorMessage);
            toolResults.push(errorMessage);
          }
        }

        // LLM„Å´ÊúÄÁµÇ„É¨„Çπ„Éù„É≥„Çπ„ÇíÁîüÊàê„Åï„Åõ„Çã
        // ToolÁµêÊûú„ÇíÂê´„ÇÄ„É¶„Éº„Ç∂„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Å®„Åó„Å¶ËøΩÂä†
        const toolResultMessage: ChatMessage = {
          role: 'user',
          content: `[Tool Results]\n${toolResults.join('\n')}`,
          timestamp: new Date(),
        };
        this.history.push(toolResultMessage);

        const finalResult = await withRetry(
          async () => {
            return await this.provider.chat(this.history, {
              model: this.currentModel,
              temperature: this.config.llm.temperature || 0.7,
              maxTokens: this.config.llm.maxTokens || 2000,
            });
          },
          {
            maxRetries: this.config.llm.maxRetries,
            delay: 1000,
            exponentialBackoff: true,
            timeout: this.config.llm.timeout,
            shouldRetry: (error: Error) => {
              const message = error.message.toLowerCase();
              return (
                message.includes('timeout') ||
                message.includes('rate limit') ||
                message.includes('network') ||
                message.includes('connection') ||
                message.includes('server error')
              );
            },
          }
        );

        if (!finalResult.success) {
          logger.error('Final LLM response error:', finalResult.error);
          throw finalResult.error!;
        }

        const finalResponse = typeof finalResult.result === 'string' 
          ? finalResult.result 
          : finalResult.result!.content || '';
        
        const trimmedFinalResponse = finalResponse.trim();
        
        // ÊúÄÁµÇ„É¨„Çπ„Éù„É≥„Çπ„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅØ„ÉÑ„Éº„É´ÁµêÊûú„ÇíËøî„Åô
        const responseToReturn = trimmedFinalResponse || toolResults.join('\n\n');

        // Final assistant message„Çíhistory„Å´ËøΩÂä†
        const finalAssistantMessage: ChatMessage = {
          role: 'assistant',
          content: responseToReturn,
          timestamp: new Date(),
        };
        this.history.push(finalAssistantMessage);
        this.limitHistorySize();

        // HistorySave
        globalProgressReporter.updateSubtask(4);
        try {
          await this.memoryManager.saveHistory(this.history);
        } catch (saveError) {
          logger.warn('Failed to save history:', saveError);
        }

        globalProgressReporter.completeTask(true);
        return responseToReturn;
      } else {
        // ÈÄöÂ∏∏„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„É¨„Çπ„Éù„É≥„Çπ„ÅÆÂ†¥Âêà
        const response = typeof llmResponse === 'string' ? llmResponse : llmResponse.content;
        
        if (!response || response.trim().length === 0) {
          logger.error('LLM returned empty response:', {
            llmResponse,
            responseType: typeof llmResponse,
            hasContent: !!(llmResponse && typeof llmResponse === 'object' && 'content' in llmResponse),
            model: this.currentModel,
            provider: this.config.llm.provider,
            availableFunctionsCount: this.availableFunctions.length,
            functionCallAttempted: !!(llmResponse && typeof llmResponse === 'object' && 'functionCall' in llmResponse)
          });
          globalProgressReporter.completeTask(false);
          throw new Error(`Response from LLM is empty (model: ${this.currentModel}, provider: ${this.config.llm.provider})`);
        }

        const trimmedResponse = response.trim();

        // AssistantMessage„ÇíHistory„Å´ËøΩÂä†
        const assistantMessage: ChatMessage = {
          role: 'assistant',
          content: trimmedResponse,
          timestamp: new Date(),
        };
        this.history.push(assistantMessage);
        this.limitHistorySize();

        // HistorySave
        globalProgressReporter.updateSubtask(4);
        
        // History„Çí SaveÔºàErroroccurred„Åó„Å¶„ÇÇ‰ºöË©±„ÅØÁ∂ôÁ∂öÔºâ
        try {
          await this.memoryManager.saveHistory(this.history);
        } catch (saveError) {
          logger.warn('Failed to save history:', saveError);
          globalProgressReporter.showWarning('Failed to save history, but conversation continues');
          // HistorySaveFailed„ÅØËá¥ÂëΩÁöÑ„Åß„ÅØ„Å™„ÅÑ
        }

        globalProgressReporter.completeTask(true);
        // perf.end(`Chat completed (attempts: ${result.attemptCount}, time: ${result.totalTime}ms)`);
        return trimmedResponse;
      }
    } catch (error) {
      logger.error('Chat error:', error);
      globalProgressReporter.completeTask(false);

      // ErrorMessage„ÇíUser„Éï„É¨„É≥„Éâ„É™„Éº„Å´Convert
      let errorMessage = 'Error occurred';
      let canRetry = false;

      if (error instanceof Error) {
        const errorMsg = error.message.toLowerCase();

        if (
          errorMsg.includes('api key') ||
          errorMsg.includes('unauthorized') ||
          errorMsg.includes('authentication')
        ) {
          errorMessage = 'API key is invalid or expired. Please check settings.';
        } else if (
          errorMsg.includes('quota') ||
          errorMsg.includes('billing') ||
          errorMsg.includes('payment')
        ) {
          errorMessage =
            'API quota or billing issues. Please check account status.';
        } else if (errorMsg.includes('timeout')) {
          errorMessage = 'Request timed out. Please try again.';
          canRetry = true;
        } else if (errorMsg.includes('rate limit') || errorMsg.includes('too many requests')) {
          errorMessage = 'Rate limit reached. Please wait.';
          canRetry = true;
        } else if (errorMsg.includes('network') || errorMsg.includes('connection')) {
          errorMessage = 'Network error occurred. Please check connection.';
          canRetry = true;
        } else if (errorMsg.includes('model') && errorMsg.includes('not found')) {
          errorMessage = `Specified model "${this.currentModel}" is not available.`;
        } else if (errorMsg.includes('input') || errorMsg.includes('Èï∑„Åô„Åé')) {
          errorMessage = error.message;
        } else {
          errorMessage = `ChatError: ${error.message}`;
          canRetry = true;
        }
      }

      // ErrorInfo„Çí„Çà„ÇäDetails„Å´Ë®òÈå≤
      const errorDetails = {
        originalError: error instanceof Error ? error.message : String(error),
        model: this.currentModel,
        provider: this.config.llm.provider,
        canRetry,
        timestamp: new Date().toISOString(),
      };

      logger.error('Detailed chat error info:', errorDetails);

      // Error„Çí„É©„ÉÉ„Éó„Åó„Å¶ËøΩÂä†Info„ÇíÂê´„ÇÅ„Çã
      const wrappedError = new Error(errorMessage);
      (wrappedError as any).details = errorDetails;
      (wrappedError as any).canRetry = canRetry;

      throw wrappedError;
    }
  }

  /**
   * TaskDecomposeÊ©üËÉΩ‰ªò„Åç„ÅÆChat
   * @param input User„ÅÆÂÖ•Âäõ
   * @returns AI„ÅÆÂøúÁ≠î
   */
  async chatWithTaskDecomposition(input: string): Promise<string> {
    const perf = new PerformanceLogger('chatWithTaskDecomposition');

    try {
      // ÂÖ•ÂäõValidation
      if (!input || input.trim().length === 0) {
        throw new Error('Input is empty');
      }

      const trimmedInput = input.trim();
      
      // MCP„ÉÑ„Éº„É´„ÅÆÂàùÊúüÂåñ„ÇíÊúÄÂ§ß5ÁßíÈñìÂæÖÊ©ü
      if (this.config.mcp?.enabled && this.availableFunctions.length === 0) {
        const maxWait = 5000; // 5Áßí
        const startTime = Date.now();
        while (Date.now() - startTime < maxWait && this.availableFunctions.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 100)); // 100msÂæÖÊ©ü
        }
        logger.debug(`MCP tools wait completed: ${this.availableFunctions.length} functions available`);
      }
      
      // Task„ÅÆË§áÈõëÂ∫¶„ÇíÂà§ÂÆö
      if (this.taskDecomposer.isComplexTask(trimmedInput)) {
        logger.info('üìù Task„ÇíDecompose„Åó„Å¶ing...');
        
        // Task„ÇíDecompose
        const subtasks = this.taskDecomposer.decompose(trimmedInput);
        
        if (subtasks.length > 1) {
          // Task„ÅåDecompose„Åï„Çå„ÅüÂ†¥Âêà„ÅÆË°®Á§∫
          logger.info('Task„Åå‰ª•‰∏ã„ÅÆ„Çµ„ÉñTask„Å´Decompose„Åïed:');
          subtasks.forEach((subtask, index) => {
            logger.info(`  ${index + 1}. ${subtask}`);
          });

          // ParallelExecuteÂèØËÉΩ„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
          const canRunParallel = this.parallelMode && this.canRunSubtasksInParallel(subtasks);
          
          let results: string[];
          
          if (canRunParallel) {
            logger.info('üöÄ „Çµ„ÉñTask„ÇíParallelExecute„Åó„Åæ„Åô');
            results = await this.executeSubtasksInParallel(subtasks);
          } else {
            logger.info('üîÑ „Çµ„ÉñTask„ÇíSequentialExecute„Åó„Åæ„Åô');
            results = await this.executeSubtasksSequentially(subtasks);
          }

          // Result„ÇíIntegrate
          const finalResponse = `TaskDecomposeExecuteResult:\n\n${results.join('\n\n')}\n\nüìä ExecuteSummary: ${subtasks.length}items„ÅÆ„Çµ„ÉñTaskof${results.filter(r => !r.includes('Erroroccurred')).length}items„ÅåSuccessdone„ÄÇ`;
          
          perf.end(`Task decomposition completed: ${subtasks.length} subtasks`);
          return finalResponse;
        }
      }
      
      // ÈÄöÂ∏∏„ÅÆChatProcessing„Å´Fallback
      return await this.chat(trimmedInput);
    } catch (error) {
      logger.error('Task decomposition error:', error);
      
      // Error„ÅÆÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆChat„Å´Fallback
      try {
        return await this.chat(input);
      } catch (fallbackError) {
        throw fallbackError;
      }
    }
  }

  async executeTask(config: TaskConfig): Promise<TaskResult> {
    const perf = new PerformanceLogger('executeTask');

    try {
      this.emit('task:start', config);

      const result = await this.taskExecutor.execute(config, this.provider);

      this.emit('task:complete', result);
      perf.end(`Task completed: ${config.description}`);

      return result;
    } catch (error) {
      const errorResult: TaskResult = {
        success: false,
        message: `Task execution error: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error : new Error(String(error)),
      };

      this.emit('task:error', errorResult);
      logger.error('Task execution error:', error);

      return errorResult;
    }
  }

  async saveSession(filename: string): Promise<void> {
    await this.memoryManager.saveSession(
      {
        id: `session-${Date.now()}`,
        startedAt: new Date(),
        config: this.convertToLegacyConfig(this.config),
        history: this.history,
      },
      filename,
    );
  }

  async loadSession(filename: string): Promise<void> {
    const session = await this.memoryManager.loadSession(filename);
    this.history = session.history;
    
    // „É≠„Éº„ÉâÂæå„Å´„É°„É¢„É™Optimize
    await this.optimizeMemory();
    
    logger.info(`„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíLoad„Åæ„Åó„Åü: ${filename}`);
  }

  getHistory(): ChatMessage[] {
    return [...this.history];
  }

  /**
   * ‰ºöË©±Â±•Ê≠¥„Çí„ÇØ„É™„Ç¢
   */
  clearHistory(): void {
    this.history = [];
    logger.info('Conversation history cleared');
  }

  /**
   * Â±•Ê≠¥„Çµ„Ç§„Ç∫„ÇíÂà∂ÈôêÔºàÊúÄÂ§ß20„É°„ÉÉ„Çª„Éº„Ç∏Ôºâ
   */
  private limitHistorySize(): void {
    const MAX_HISTORY_MESSAGES = 20;
    if (this.history.length > MAX_HISTORY_MESSAGES) {
      const removed = this.history.length - MAX_HISTORY_MESSAGES;
      this.history = this.history.slice(-MAX_HISTORY_MESSAGES);
      logger.debug(`Trimmed ${removed} old messages from history to prevent large requests`);
    }
  }

  clearHistory(): void {
    this.history = [];
    logger.info('History cleared');
  }

  getCurrentModel(): string {
    return this.currentModel;
  }

  setModel(model: string): void {
    this.currentModel = model;
    logger.info(`Model changed: ${model}`);
  }

  toggleParallelMode(): boolean {
    this.parallelMode = !this.parallelMode;
    this.taskExecutor.setParallelMode(this.parallelMode);
    return this.parallelMode;
  }

  toggleVerboseMode(): boolean {
    this.verboseMode = !this.verboseMode;
    if (this.verboseMode) {
      logger.setLevel(LogLevel.DEBUG);
      logger.info('Verbose mode enabled');
    } else {
      // „Éá„Éï„Ç©„É´„Éà„É¨„Éô„É´„Å´Êàª„Åô
      const defaultLevel = this.parseLogLevel(this.config.app.logLevel);
      logger.setLevel(defaultLevel);
      logger.info('Verbose mode disabled');
    }
    return this.verboseMode;
  }

  private parseLogLevel(level: string): LogLevel {
    switch (level.toLowerCase()) {
      case 'error':
        return LogLevel.ERROR;
      case 'warn':
        return LogLevel.WARN;
      case 'info':
        return LogLevel.INFO;
      case 'debug':
        return LogLevel.DEBUG;
      default:
        return LogLevel.INFO;
    }
  }

  /**
   * MCPManager„ÇíConfig„Åó„Å¶Tool„Éò„É´„Éë„Éº„ÇíInitialize
   */
  async setupMCPTools(mcpManager: MCPManager): Promise<void> {
    // ÂÜÖÈÉ®Èñ¢Êï∞„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£Ë®≠ÂÆö„ÇíÊ∫ñÂÇô
    const securityConfig = this.config.functions?.filesystem?.security || {
      allowedPaths: [process.cwd()],
      allowCurrentDirectoryChange: true,
      restrictToStartupDirectory: true
    };

    // MCPFunctionConverter„Çí‰ΩúÊàêÔºàÂÜÖÈÉ®Èñ¢Êï∞Ë®≠ÂÆö‰ªò„ÅçÔºâ
    const bashConfig = this.config.functions?.bash?.enabled ? this.config.functions.bash.security : undefined;
    this.mcpFunctionConverter = new MCPFunctionConverter(mcpManager, securityConfig, bashConfig);
    
    // MCPToolsHelper„ÇíÂàùÊúüÂåñÔºàFunctionConverter„ÇíÊ∏°„ÅôÔºâ
    this.mcpToolsHelper = new MCPToolsHelper(mcpManager, this.mcpFunctionConverter);
    
    // Function Calling„ÅßÂà©Áî®ÂèØËÉΩ„Å™„ÉÑ„Éº„É´„ÇíÊõ¥Êñ∞
    this.availableFunctions = await this.mcpFunctionConverter.convertAllTools();
    
    logger.debug(`Function definitions loaded: ${this.availableFunctions.length} functions available`);
    logger.debug('Available functions:', this.availableFunctions.map(f => f.name));
    
    // ÂÜÖÈÉ®Èñ¢Êï∞„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅØ„É≠„Ç∞Âá∫Âäõ
    const internalFunctions = this.availableFunctions.filter(f => f.name.startsWith('internal_'));
    if (internalFunctions.length > 0) {
      logger.debug(`Internal functions loaded: ${internalFunctions.length} functions`, 
        internalFunctions.map(f => f.name));
    }
  }

  /**
   * MCPTool„Çí‰ΩøÁî®„Åó„Å¶Task„ÇíExecute
   */
  async executeTaskWithMCP(config: TaskConfig): Promise<TaskResult> {
    if (!this.mcpToolsHelper || !this.mcpTaskPlanner) {
      logger.warn('MCP tools not initialized. Switching to normal task execution');
      return this.executeTask(config);
    }

    const perf = new PerformanceLogger('executeTaskWithMCP');

    try {
      this.emit('task:start', config);

      // TaskExecute„Éó„É©„É≥„Çí‰ΩúÊàê
      const executionPlan = await this.mcpTaskPlanner.createExecutionPlan(config.description);
      logger.info(`Execution plan created: ${executionPlan.steps.length} steps`, executionPlan);

      // ÂêÑStep„ÇíExecute
      const stepResults: unknown[] = [];
      for (const step of executionPlan.steps) {
        try {
          logger.info(`Executing step: ${step.description}`);
          const stepResult = await this.mcpToolsHelper.executeTool(step.tool, step.params);
          stepResults.push(stepResult);
          logger.info(`Step completed: ${step.description}`);
        } catch (error) {
          logger.error(`Step error: ${step.description}`, error);
          stepResults.push({ error: error instanceof Error ? error.message : String(error) });
        }
      }

      // Result„Çí„Åæ„Å®„ÇÅ„Å¶Ëøî„Åô
      const result: TaskResult = {
        success: stepResults.every((r) => !(r && typeof r === 'object' && 'error' in r)),
        message: config.description,
        data: {
          executionPlan,
          stepResults,
          summary: this.summarizeResults(stepResults),
        },
      };

      this.emit('task:complete', result);
      perf.end(`MCP Task completed: ${config.description}`);

      return result;
    } catch (error) {
      const errorResult: TaskResult = {
        success: false,
        message: `MCP task execution error: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error : new Error(String(error)),
      };

      this.emit('task:error', errorResult);
      logger.error('MCP Task execution error:', error);

      return errorResult;
    }
  }

  /**
   * Result„ÇíSummaryÂåñ
   */
  private summarizeResults(results: unknown[]): string {
    const successCount = results.filter(
      (r) => !(r && typeof r === 'object' && 'error' in r),
    ).length;
    const errorCount = results.length - successCount;

    return `${successCount} of ${results.length} steps succeeded, ${errorCount} errors`;
  }

  /**
   * Âà©Áî®ÂèØËÉΩ„Å™MCPTool„ÅÆ‰∏ÄË¶ß„ÇíGet
   */
  async getAvailableMCPTools(): Promise<{ name: string; description: string }[]> {
    if (!this.mcpToolsHelper) {
      return [];
    }

    try {
      const tools = await this.mcpToolsHelper.getAvailableTools();
      return tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
      }));
    } catch (error) {
      logger.error('Error getting MCP tool list:', error);
      return [];
    }
  }

  /**
   * ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„ÇãFunction CallingÁî®Èñ¢Êï∞„ÅÆÊï∞„ÇíÂèñÂæó
   */
  getAvailableFunctionCount(): number {
    return this.availableFunctions.length;
  }

  /**
   * MCPServer„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíGet
   */
  getMCPServerStatus(): Map<string, boolean> | null {
    if (!this.mcpToolsHelper) {
      return null;
    }
    return this.mcpToolsHelper.getServerStatus();
  }

  /**
   * MCPÂàùÊúüÂåñÈÄ≤Êçó„ÇíÂèñÂæó
   */
  getMCPInitializationProgress(): {
    isInitializing: boolean;
    total: number;
    completed: number;
    failed: number;
    servers: Array<{
      name: string;
      type: 'stdio' | 'http' | 'sse';
      status: 'pending' | 'connecting' | 'initializing' | 'listing-tools' | 'completed' | 'failed';
      error?: string;
      startedAt?: Date;
      completedAt?: Date;
      toolCount?: number;
      duration?: number;
    }>;
  } | null {
    if (!this.mcpToolsHelper) {
      return null;
    }
    return this.mcpToolsHelper.getInitializationProgress();
  }

  /**
   * StepExecuteResult„ÅÆDetailsSummary„Çí‰ΩúÊàê
   */
  private createDetailedSummary(
    stepResults: Array<{
      stepIndex: number;
      description: string;
      success: boolean;
      result?: unknown;
      error?: string;
      duration?: number;
    }>,
    totalSteps: number,
  ): string {
    const successCount = stepResults.filter((r) => r.success).length;
    const errorCount = stepResults.filter((r) => !r.success).length;
    const totalDuration = stepResults.reduce((sum, r) => sum + (r.duration || 0), 0);

    const summaryParts = [
      `${successCount} of ${totalSteps} steps succeeded, ${errorCount} errors`,
      `ExecuteÊôÇÈñì: ${totalDuration}ms`,
    ];

    // Error„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØError„ÅÆDetails„ÇíËøΩÂä†
    if (errorCount > 0) {
      const failedSteps = stepResults
        .filter((r) => !r.success)
        .map((r) => `- ${r.description}: ${r.error}`)
        .join('\n');
      summaryParts.push(`Failed„Åó„ÅüStep:\n${failedSteps}`);
    }

    return summaryParts.join('\n');
  }

  /**
   * „Çµ„ÉñTask„ÅåParallelExecuteÂèØËÉΩ„Åã„ÇíÂà§ÂÆö
   */
  private canRunSubtasksInParallel(subtasks: string[]): boolean {
    // „Ç∑„É≥„Éó„É´„Å™ParallelExecuteÂà§ÂÆö„É´„Éº„É´
    const conflictKeywords = [
      'Âêå„Åò„Éï„Ç°„Ç§„É´',
      'È†ÜÁï™',
      'Sequential',
      'Ââç„ÅÆTask',
      '‰æùÂ≠ò',
      'Result„Çí‰ΩøÁî®',
      'Result„ÇíÂà©Áî®',
      '„ÅÆÂæå„Åß',
      '„Å´Âü∫„Å•„ÅÑ„Å¶',
    ];

    // TaskÈñì„ÅßÁ´∂Âêà„Åô„Çã„Ç≠„Éº„ÉØ„Éº„Éâ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const hasConflict = subtasks.some((subtask) =>
      conflictKeywords.some((keyword) => subtask.includes(keyword))
    );

    if (hasConflict) {
      logger.debug('„Çµ„ÉñTask„Å´‰æùÂ≠òÈñ¢‰øÇ„ÅåÊ§úÂá∫„Åïed„ÄÇSequentialExecute„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ');
      return false;
    }

    // „Éï„Ç°„Ç§„É´„Éë„Çπ„ÅÆÁ´∂Âêà„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const usedFiles = new Set<string>();
    for (const subtask of subtasks) {
      const files = this.extractFilesFromSubtask(subtask);
      const hasFileConflict = files.some(file => usedFiles.has(file));
      
      if (hasFileConflict) {
        logger.debug('„Çµ„ÉñTaskÈñì„Åß„Éï„Ç°„Ç§„É´„ÅÆÁ´∂Âêà„ÅåÊ§úÂá∫„Åïed„ÄÇSequentialExecute„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ');
        return false;
      }
      
      // forEach + async„ÅÆÂïèÈ°å„Çí‰øÆÊ≠£Ôºöfor...of„É´„Éº„Éó„Çí‰ΩøÁî®
      for (const file of files) {
        usedFiles.add(file);
      }
    }

    return true;
  }

  /**
   * „Çµ„ÉñTask„Åã„ÇâÈñ¢ÈÄ£„Éï„Ç°„Ç§„É´„ÇíÊäΩÂá∫
   */
  private extractFilesFromSubtask(subtask: string): string[] {
    const files: string[] = [];
    
    // „Éï„Ç°„Ç§„É´„Éë„Çπ„ÅÆ„Éë„Çø„Éº„É≥„ÇíÊ§úÁ¥¢
    const filePatterns = [
      /[\w-]+\.[\w]+/g, // file.extÂΩ¢Âºè
      /src\/[\w\/.-]+/g, // src/„Åã„ÇâÂßã„Åæ„Çã„Éë„Çπ
      /\.\/[\w\/.-]+/g, // Áõ∏ÂØæ„Éë„Çπ
      /\/[\w\/.-]+/g, // Áµ∂ÂØæ„Éë„Çπ
    ];
    
    for (const pattern of filePatterns) {
      const matches = subtask.match(pattern);
      if (matches) {
        files.push(...matches);
      }
    }
    
    return [...new Set(files)]; // ÈáçË§áÈô§Âéª
  }

  /**
   * „Çµ„ÉñTask„ÇíParallelExecute
   */
  private async executeSubtasksInParallel(subtasks: string[]): Promise<string[]> {
    const { globalProgressReporter } = await import('../ui/progress.js');

    // „Çµ„ÉñTask„ÇíParallelTask„Å´Convert
    const parallelTasks = subtasks.map((subtask, index) => ({
      id: `subtask-${index}`,
      description: subtask,
      priority: 5,
      task: async () => {
        logger.info(`üîÑ „Çµ„ÉñTask ${index + 1} Started: ${subtask}`);
        try {
          const result = await this.chat(subtask);
          logger.info(`‚úÖ „Çµ„ÉñTask ${index + 1} Completed`);
          return `„Çµ„ÉñTask ${index + 1}: ${result}`;
        } catch (error) {
          const errorMsg = `„Çµ„ÉñTask ${index + 1} „ÅßErroroccurreddone: ${error instanceof Error ? error.message : String(error)}`;
          logger.error(`‚ùå ${errorMsg}`);
          return errorMsg;
        }
      },
    }));

    // ParallelExecute
    const parallelResults = await this.parallelExecutor.executeParallelWithDetails(
      parallelTasks,
      (completed, total, currentTask) => {
        globalProgressReporter.showInfo(`ParallelExecuteÈÄ≤Êçó: ${completed}/${total} - ${currentTask}`);
      }
    );

    // Result„ÇícharactersÂàóÈÖçÂàó„Å´Convert
    return parallelResults.map(pr => 
      pr.success ? pr.data as string : `Error: ${pr.error?.message || 'Unknown error'}`
    );
  }

  /**
   * „Çµ„ÉñTask„ÇíSequentialExecute
   */
  private async executeSubtasksSequentially(subtasks: string[]): Promise<string[]> {
    const results: string[] = [];
    
    for (let i = 0; i < subtasks.length; i++) {
      const subtask = subtasks[i];
      logger.info(`\nüîÑ „Çµ„ÉñTask ${i + 1}/${subtasks.length} „ÇíExecute‰∏≠: ${subtask}`);
      
      try {
        const subtaskResult = await this.chat(subtask);
        results.push(`„Çµ„ÉñTask ${i + 1}: ${subtaskResult}`);
        logger.info(`‚úÖ „Çµ„ÉñTask ${i + 1} Completed`);
      } catch (error) {
        const errorMsg = `„Çµ„ÉñTask ${i + 1} „ÅßErroroccurreddone: ${error instanceof Error ? error.message : String(error)}`;
        results.push(errorMsg);
        logger.error(`‚ùå ${errorMsg}`);
      }
    }

    return results;
  }

}

/**
 * ReActÔºàReason-and-ActÔºâÁ∂ôÁ∂öÂÆüË°å„Ç≥„É≥„Éà„É≠„Éº„É©„Éº
 * Êé®Ë´ñ‚ÜíË°åÂãï‚ÜíË¶≥ÂØü„ÅÆ„É´„Éº„Éó„ÅßÂÆå‰∫Ü„Åæ„ÅßËá™ÂãïÁ∂ôÁ∂öÂÆüË°å
 */
export class ReActController {
  private agent: AgentCore;
  private maxIterations: number = 20;
  private currentIteration: number = 0;
  private isComplete: boolean = false;
  private sessionState: Map<string, any> = new Map();
  private taskHistory: Array<{
    iteration: number;
    reasoning: string;
    action: string;
    observation: string;
    timestamp: Date;
  }> = [];

  constructor(agent: AgentCore, maxIterations: number = 20) {
    this.agent = agent;
    this.maxIterations = maxIterations;
  }

  /**
   * Á∂ôÁ∂öÂÆüË°å„É°„Ç§„É≥„É´„Éº„Éó - ÂÆå‰∫Ü„Åæ„ÅßËá™ÂãïÂÆüË°å
   */
  async executeUntilComplete(
    initialPrompt: string,
    completionCriteria?: (history: any[]) => boolean
  ): Promise<{
    success: boolean;
    finalResult: string;
    iterations: number;
    history: any[];
    completionReason: 'success' | 'max_iterations' | 'error' | 'user_requested';
  }> {
    logger.info(`üîÑ ReActÁ∂ôÁ∂öÂÆüË°åÈñãÂßã: "${initialPrompt}"`);
    
    this.reset();
    let currentPrompt = initialPrompt;
    let finalResult = '';
    let completionReason: 'success' | 'max_iterations' | 'error' | 'user_requested' = 'success';

    try {
      while (!this.isComplete && this.currentIteration < this.maxIterations) {
        this.currentIteration++;
        logger.info(`\nüìç ÂèçÂæ© ${this.currentIteration}/${this.maxIterations}`);

        // Phase 1: ReasoningÔºàÊé®Ë´ñÔºâ
        const reasoning = await this.performReasoning(currentPrompt);
        logger.debug(`üß† Êé®Ë´ñ: ${reasoning.substring(0, 200)}...`);

        // Phase 2: ActionÔºàË°åÂãïÔºâ
        const actionResult = await this.performAction(reasoning);
        logger.debug(`‚ö° Ë°åÂãïÁµêÊûú: ${actionResult.substring(0, 200)}...`);

        // Phase 3: ObservationÔºàË¶≥ÂØüÔºâ
        const observation = await this.performObservation(actionResult);
        logger.debug(`üëÄ Ë¶≥ÂØü: ${observation.substring(0, 200)}...`);

        // „Çø„Çπ„ÇØÂ±•Ê≠¥„Å´Ë®òÈå≤
        this.taskHistory.push({
          iteration: this.currentIteration,
          reasoning,
          action: actionResult,
          observation,
          timestamp: new Date()
        });

        // ÂÆå‰∫ÜÂà§ÂÆö
        if (completionCriteria) {
          this.isComplete = completionCriteria(this.taskHistory);
        } else {
          this.isComplete = this.defaultCompletionCheck(observation);
        }

        finalResult = observation;

        if (!this.isComplete) {
          // Ê¨°„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÇíÁîüÊàê
          currentPrompt = this.generateNextPrompt(reasoning, actionResult, observation);
        } else {
          logger.info('‚úÖ „Çø„Çπ„ÇØÂÆå‰∫ÜÊù°‰ª∂„ÇíÊ∫Ä„Åü„Åó„Åæ„Åó„Åü');
          break;
        }

        // Áü≠„ÅÑ‰ºëÊÜ©Ôºà„É¨„Éº„ÉàÂà∂ÈôêÂõûÈÅøÔºâ
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      if (this.currentIteration >= this.maxIterations) {
        completionReason = 'max_iterations';
        logger.warn(`‚ö†Ô∏è ÊúÄÂ§ßÂèçÂæ©Êï∞(${this.maxIterations})„Å´ÈÅî„Åó„Åæ„Åó„Åü`);
      }

      logger.info(`üèÅ ReActÁ∂ôÁ∂öÂÆüË°åÂÆå‰∫Ü: ${this.currentIteration}Âõû„ÅÆÂèçÂæ©`);

      return {
        success: this.isComplete,
        finalResult,
        iterations: this.currentIteration,
        history: this.taskHistory,
        completionReason
      };

    } catch (error) {
      logger.error('ReActÂÆüË°å„Ç®„É©„Éº:', error);
      return {
        success: false,
        finalResult: `„Ç®„É©„Éº: ${error instanceof Error ? error.message : String(error)}`,
        iterations: this.currentIteration,
        history: this.taskHistory,
        completionReason: 'error'
      };
    }
  }

  /**
   * Phase 1: Êé®Ë´ñ„Éï„Çß„Éº„Ç∫
   */
  private async performReasoning(prompt: string): Promise<string> {
    const reasoningPrompt = `
‰ª•‰∏ã„ÅÆ„Çø„Çπ„ÇØ„Å´„Å§„ÅÑ„Å¶„ÄÅÊ¨°„Å´‰Ωï„ÇíË°å„ÅÜ„Åπ„Åç„ÅãË´ñÁêÜÁöÑ„Å´Êé®Ë´ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÁèæÂú®„ÅÆ„Çø„Çπ„ÇØ: ${prompt}

„Åì„Çå„Åæ„Åß„ÅÆÈÄ≤Êçó:
${this.taskHistory.length > 0 ? 
  this.taskHistory.slice(-3).map(h => 
    `- ÂèçÂæ©${h.iteration}: ${h.observation.substring(0, 100)}...`
  ).join('\n') : 
  'Ôºà„Åæ„Å†‰ΩúÊ•≠„ÇíÈñãÂßã„Åó„Å¶„ÅÑ„Åæ„Åõ„ÇìÔºâ'
}

Ê¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊ±∫ÂÆö„Åô„Çã„Åü„ÇÅ„Å´Ôºö
1. ÁèæÂú®„ÅÆÁä∂Ê≥Å„ÇíÂàÜÊûê
2. ÁõÆÊ®ôÈÅîÊàê„ÅÆ„Åü„ÇÅ„Å´ÂøÖË¶Å„Å™Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÁâπÂÆö
3. ÂÖ∑‰ΩìÁöÑ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„Éó„É©„É≥„ÇíÊèêÁ§∫

Êé®Ë´ñÁµêÊûú:`;

    return await this.agent.chat(reasoningPrompt);
  }

  /**
   * Phase 2: Ë°åÂãï„Éï„Çß„Éº„Ç∫
   */
  private async performAction(reasoning: string): Promise<string> {
    const actionPrompt = `
‰ª•‰∏ã„ÅÆÊé®Ë´ñ„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅÂÖ∑‰ΩìÁöÑ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

Êé®Ë´ñÂÜÖÂÆπ: ${reasoning}

ÂÆüÈöõ„Å´‰ª•‰∏ã„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅÆË°åÂãï„ÇíÂèñ„Å£„Å¶„Åè„Å†„Åï„ÅÑÔºö
- „Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøÊõ∏„Åç
- „Ç≥„Éû„É≥„Éâ„ÅÆÂÆüË°å
- „Ç≥„Éº„Éâ„ÅÆÁîüÊàê„Éª‰øÆÊ≠£
- ÊÉÖÂ†±„ÅÆÊ§úÁ¥¢„ÉªË™øÊüª
- „Åù„ÅÆ‰ªñÂøÖË¶Å„Å™‰ΩúÊ•≠

Ë°åÂãï„ÇíÂÆüË°å„Åó„Å¶„Åù„ÅÆÁµêÊûú„ÇíÂ†±Âëä„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;

    return await this.agent.chat(actionPrompt);
  }

  /**
   * Phase 3: Ë¶≥ÂØü„Éï„Çß„Éº„Ç∫
   */
  private async performObservation(actionResult: string): Promise<string> {
    const observationPrompt = `
‰ª•‰∏ã„ÅÆË°åÂãïÁµêÊûú„ÇíË¶≥ÂØü„ÉªÂàÜÊûê„Åó„Å¶„ÄÅÊ¨°„ÅÆÂà§Êñ≠ÊùêÊñô„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

Ë°åÂãïÁµêÊûú: ${actionResult}

‰ª•‰∏ã„ÅÆË¶≥ÁÇπ„ÅßÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
1. Ë°åÂãï„ÅØÊàêÂäü„Åó„Åü„ÅãÔºü
2. ÁõÆÊ®ô„Å´Âêë„Åã„Å£„Å¶ÂâçÈÄ≤„Åß„Åç„Åü„ÅãÔºü
3. Êñ∞„Åü„Å´Âà§Êòé„Åó„ÅüÊÉÖÂ†±„ÇÑË™≤È°å„ÅØ„ÅÇ„Çã„ÅãÔºü
4. „Çø„Çπ„ÇØÂÆå‰∫Ü„Å´Âêë„Åë„Å¶Ê¨°„Å´ÂøÖË¶Å„Å™„Åì„Å®„ÅØ‰Ωï„ÅãÔºü
5. „Åì„ÅÆ„Çø„Çπ„ÇØ„ÅØÂÆå‰∫Ü„Åó„Åü„Å®Âà§Êñ≠„Åß„Åç„Çã„ÅãÔºü

Ë¶≥ÂØüÁµêÊûú:`;

    return await this.agent.chat(observationPrompt);
  }

  /**
   * „Éá„Éï„Ç©„É´„Éà„ÅÆÂÆå‰∫ÜÂà§ÂÆö
   */
  private defaultCompletionCheck(observation: string): boolean {
    const completionKeywords = [
      '„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü',
      '‰ΩúÊ•≠ÂÆå‰∫Ü',
      'ÂÆüË£ÖÂÆå‰∫Ü',
      'ÂÖ®„Å¶ÂÆå‰∫Ü',
      '„Åô„Åπ„Å¶ÂÆå‰∫Ü',
      'successfully completed',
      'task completed',
      'finished',
      'Ë¶Å‰ª∂„ÇíÊ∫Ä„Åü„Åó'
    ];

    const observationLower = observation.toLowerCase();
    return completionKeywords.some(keyword => 
      observationLower.includes(keyword.toLowerCase())
    );
  }

  /**
   * Ê¨°„ÅÆ„Éó„É≠„É≥„Éó„ÉàÁîüÊàê
   */
  private generateNextPrompt(reasoning: string, action: string, observation: string): string {
    return `
ÂâçÂõû„ÅÆÂàÜÊûêÁµêÊûú„ÇíË∏è„Åæ„Åà„Å¶„ÄÅÂºï„ÅçÁ∂ö„Åç„Çø„Çπ„ÇØ„ÇíÈÄ≤„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

ÂâçÂõû„ÅÆÊé®Ë´ñ: ${reasoning.substring(0, 200)}...
ÂâçÂõû„ÅÆË°åÂãï: ${action.substring(0, 200)}...  
ÂâçÂõû„ÅÆË¶≥ÂØü: ${observation.substring(0, 200)}...

„Åì„Çå„Çâ„ÅÆÁµêÊûú„ÇíË∏è„Åæ„Åà„Å¶„ÄÅÊ¨°„Å´ÂÆüË°å„Åô„Åπ„Åç‰ΩúÊ•≠„ÇíÁ∂ôÁ∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
   */
  private reset(): void {
    this.currentIteration = 0;
    this.isComplete = false;
    this.sessionState.clear();
    this.taskHistory = [];
  }

  /**
   * ÁèæÂú®„ÅÆÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÂèñÂæó
   */
  getProgress(): {
    iteration: number;
    maxIterations: number;
    isComplete: boolean;
    history: any[];
  } {
    return {
      iteration: this.currentIteration,
      maxIterations: this.maxIterations,
      isComplete: this.isComplete,
      history: [...this.taskHistory]
    };
  }

  /**
   * ÊâãÂãïÂÆå‰∫ÜË®≠ÂÆö
   */
  markComplete(): void {
    this.isComplete = true;
    logger.info('‚úã ÊâãÂãïÂÆå‰∫Ü„ÅåË®≠ÂÆö„Åï„Çå„Åæ„Åó„Åü');
  }
}

/**
 * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖãÁÆ°ÁêÜ - „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„Éô„Éº„Çπ
 */
export class SessionStateManager {
  private sessionId: string;
  private stateFilePath: string;
  private sessionFilePath: string;
  private progressFilePath: string;

  constructor(sessionId?: string) {
    this.sessionId = sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Áä∂ÊÖãÁÆ°ÁêÜ„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê
    const storageDir = path.join(process.cwd(), 'storage');
    const sessionDir = path.join(storageDir, 'sessions', this.sessionId);
    
    // „Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
    try {
      if (!fs.existsSync(sessionDir)) {
        fs.mkdirSync(sessionDir, { recursive: true });
      }
    } catch (error) {
      logger.warn('„Çª„ÉÉ„Ç∑„Éß„É≥„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê„Å´Â§±Êïó:', error);
    }
    
    this.stateFilePath = path.join(sessionDir, 'state.json');
    this.sessionFilePath = path.join(sessionDir, 'session.json');
    this.progressFilePath = path.join(sessionDir, 'progress.json');
    
    logger.debug(`„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜÂàùÊúüÂåñ: ${this.sessionId}`);
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„Çí‰øùÂ≠ò
   */
  async saveSessionState(state: {
    currentTask?: string;
    reactHistory?: any[];
    variables?: Map<string, any>;
    metadata?: any;
  }): Promise<void> {
    try {
      const stateData = {
        sessionId: this.sessionId,
        timestamp: new Date().toISOString(),
        currentTask: state.currentTask,
        reactHistory: state.reactHistory || [],
        variables: state.variables ? Object.fromEntries(state.variables) : {},
        metadata: state.metadata || {}
      };

      await fs.promises.writeFile(this.stateFilePath, JSON.stringify(stateData, null, 2), 'utf8');
      logger.debug(`„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã‰øùÂ≠ò: ${this.stateFilePath}`);
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã‰øùÂ≠ò„Ç®„É©„Éº:', error);
    }
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÇíË™≠„ÅøËæº„Åø
   */
  async loadSessionState(): Promise<{
    currentTask?: string;
    reactHistory?: any[];
    variables?: Map<string, any>;
    metadata?: any;
  }> {
    try {
      if (!fs.existsSync(this.stateFilePath)) {
        return {};
      }

      const stateData = JSON.parse(await fs.promises.readFile(this.stateFilePath, 'utf8'));
      
      return {
        currentTask: stateData.currentTask,
        reactHistory: stateData.reactHistory || [],
        variables: new Map(Object.entries(stateData.variables || {})),
        metadata: stateData.metadata || {}
      };
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖãË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      return {};
    }
  }

  /**
   * ÈÄ≤ÊçóÁä∂Ê≥Å„Çí‰øùÂ≠ò
   */
  async saveProgress(progress: {
    totalTasks: number;
    completedTasks: number;
    currentTaskIndex: number;
    taskStatuses: Array<{
      id: string;
      name: string;
      status: 'pending' | 'in_progress' | 'completed' | 'failed';
      startedAt?: Date;
      completedAt?: Date;
      error?: string;
    }>;
  }): Promise<void> {
    try {
      const progressData = {
        ...progress,
        sessionId: this.sessionId,
        updatedAt: new Date().toISOString()
      };

      await fs.promises.writeFile(this.progressFilePath, JSON.stringify(progressData, null, 2), 'utf8');
      logger.debug('ÈÄ≤ÊçóÁä∂Ê≥Å‰øùÂ≠òÂÆå‰∫Ü');
    } catch (error) {
      logger.error('ÈÄ≤ÊçóÁä∂Ê≥Å‰øùÂ≠ò„Ç®„É©„Éº:', error);
    }
  }

  /**
   * ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíË™≠„ÅøËæº„Åø
   */
  async loadProgress(): Promise<{
    totalTasks: number;
    completedTasks: number;
    currentTaskIndex: number;
    taskStatuses: any[];
  } | null> {
    try {
      if (!fs.existsSync(this.progressFilePath)) {
        return null;
      }

      const progressData = JSON.parse(await fs.promises.readFile(this.progressFilePath, 'utf8'));
      return progressData;
    } catch (error) {
      logger.error('ÈÄ≤ÊçóÁä∂Ê≥ÅË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      return null;
    }
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±„Çí‰øùÂ≠ò
   */
  async saveSessionInfo(info: {
    startedAt: Date;
    initialPrompt: string;
    config?: any;
    userSettings?: any;
  }): Promise<void> {
    try {
      const sessionData = {
        sessionId: this.sessionId,
        ...info,
        startedAt: info.startedAt.toISOString()
      };

      await fs.promises.writeFile(this.sessionFilePath, JSON.stringify(sessionData, null, 2), 'utf8');
      logger.debug('„Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±‰øùÂ≠òÂÆå‰∫Ü');
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±‰øùÂ≠ò„Ç®„É©„Éº:', error);
    }
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíË™≠„ÅøËæº„Åø
   */
  async loadSessionInfo(): Promise<{
    startedAt: Date;
    initialPrompt: string;
    config?: any;
    userSettings?: any;
  } | null> {
    try {
      if (!fs.existsSync(this.sessionFilePath)) {
        return null;
      }

      const sessionData = JSON.parse(await fs.promises.readFile(this.sessionFilePath, 'utf8'));
      
      return {
        ...sessionData,
        startedAt: new Date(sessionData.startedAt)
      };
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      return null;
    }
  }

  /**
   * ‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É† - „Éï„Ç°„Ç§„É´‰øùÂ≠ò
   */
  async saveVirtualFile(filePath: string, content: string, metadata?: any): Promise<void> {
    try {
      const virtualDir = path.join(path.dirname(this.stateFilePath), 'virtual_fs');
      if (!fs.existsSync(virtualDir)) {
        fs.mkdirSync(virtualDir, { recursive: true });
      }

      const virtualFile = {
        content,
        metadata: metadata || {},
        createdAt: new Date().toISOString(),
        filePath
      };

      const fileName = filePath.replace(/[/\\]/g, '_');
      const virtualFilePath = path.join(virtualDir, `${fileName}.json`);
      
      await fs.promises.writeFile(virtualFilePath, JSON.stringify(virtualFile, null, 2), 'utf8');
      logger.debug(`‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´‰øùÂ≠ò: ${filePath}`);
    } catch (error) {
      logger.error('‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´‰øùÂ≠ò„Ç®„É©„Éº:', error);
    }
  }

  /**
   * ‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É† - „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
   */
  async loadVirtualFile(filePath: string): Promise<{
    content: string;
    metadata: any;
    createdAt: string;
  } | null> {
    try {
      const virtualDir = path.join(path.dirname(this.stateFilePath), 'virtual_fs');
      const fileName = filePath.replace(/[/\\]/g, '_');
      const virtualFilePath = path.join(virtualDir, `${fileName}.json`);

      if (!fs.existsSync(virtualFilePath)) {
        return null;
      }

      const virtualFile = JSON.parse(await fs.promises.readFile(virtualFilePath, 'utf8'));
      return virtualFile;
    } catch (error) {
      logger.error('‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
      return null;
    }
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºàÂè§„ÅÑ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§Ôºâ
   */
  async cleanup(): Promise<void> {
    try {
      const sessionDir = path.dirname(this.stateFilePath);
      if (fs.existsSync(sessionDir)) {
        await fs.promises.rm(sessionDir, { recursive: true });
        logger.debug(`„Çª„ÉÉ„Ç∑„Éß„É≥„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü: ${this.sessionId}`);
      }
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Ç®„É©„Éº:', error);
    }
  }

  /**
   * Âà©Áî®ÂèØËÉΩ„Å™„Çª„ÉÉ„Ç∑„Éß„É≥‰∏ÄË¶ß„ÇíÂèñÂæó
   */
  static async listSessions(): Promise<Array<{
    sessionId: string;
    startedAt: Date;
    initialPrompt: string;
  }>> {
    try {
      const storageDir = path.join(process.cwd(), 'storage', 'sessions');
      if (!fs.existsSync(storageDir)) {
        return [];
      }

      const sessionDirs = await fs.promises.readdir(storageDir);
      const sessions = [];

      for (const sessionDir of sessionDirs) {
        try {
          const sessionFilePath = path.join(storageDir, sessionDir, 'session.json');
          if (fs.existsSync(sessionFilePath)) {
            const sessionData = JSON.parse(await fs.promises.readFile(sessionFilePath, 'utf8'));
            sessions.push({
              sessionId: sessionData.sessionId,
              startedAt: new Date(sessionData.startedAt),
              initialPrompt: sessionData.initialPrompt
            });
          }
        } catch (error) {
          logger.debug(`„Çª„ÉÉ„Ç∑„Éß„É≥Ë™≠„ÅøËæº„Åø„Çπ„Ç≠„ÉÉ„Éó: ${sessionDir}`);
        }
      }

      return sessions.sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime());
    } catch (error) {
      logger.error('„Çª„ÉÉ„Ç∑„Éß„É≥‰∏ÄË¶ßÂèñÂæó„Ç®„É©„Éº:', error);
      return [];
    }
  }

  getSessionId(): string {
    return this.sessionId;
  }
}

/**
 * Á∂ôÁ∂öÂÆüË°åÁî®„ÅÆÈ´òÂ∫¶„Çø„Çπ„ÇØÂàÜËß£„ÉªËøΩË∑°„Ç∑„Çπ„ÉÜ„É†
 */
export class ContinuousTaskManager {
  private sessionManager: SessionStateManager;
  private tasks: Map<string, TaskNode> = new Map();
  private currentRootTask: string | null = null;
  
  constructor(sessionId?: string) {
    this.sessionManager = new SessionStateManager(sessionId);
  }

  /**
   * „É°„Ç§„É≥„Çø„Çπ„ÇØ„ÇíÂàÜËß£„Åó„Å¶ÂÆüË°å„Éó„É©„É≥„Çí‰ΩúÊàê
   */
  async createExecutionPlan(mainTask: string): Promise<ExecutionPlan> {
    const taskId = this.generateTaskId();
    const rootTask: TaskNode = {
      id: taskId,
      name: mainTask,
      description: mainTask,
      status: 'pending',
      subtasks: [],
      dependencies: [],
      priority: 10,
      estimatedDuration: 0,
      actualDuration: 0,
      createdAt: new Date(),
      metadata: {}
    };

    // LLM„Çí‰ΩøÁî®„Åó„ÅüÈ´òÂ∫¶„Å™„Çø„Çπ„ÇØÂàÜËß£
    const decompositionResult = await this.decomposeTaskWithLLM(mainTask);
    
    // „Çµ„Éñ„Çø„Çπ„ÇØ„Çí‰ΩúÊàê
    for (const subtaskDesc of decompositionResult.subtasks) {
      const subtaskId = this.generateTaskId();
      const subtask: TaskNode = {
        id: subtaskId,
        name: subtaskDesc.name,
        description: subtaskDesc.description,
        status: 'pending',
        subtasks: [],
        dependencies: subtaskDesc.dependencies || [],
        priority: subtaskDesc.priority || 5,
        estimatedDuration: subtaskDesc.estimatedMinutes || 10,
        actualDuration: 0,
        createdAt: new Date(),
        metadata: {
          category: subtaskDesc.category,
          tools: subtaskDesc.requiredTools
        }
      };
      
      rootTask.subtasks.push(subtaskId);
      this.tasks.set(subtaskId, subtask);
    }

    this.tasks.set(taskId, rootTask);
    this.currentRootTask = taskId;

    const executionPlan: ExecutionPlan = {
      id: this.generateTaskId(),
      rootTaskId: taskId,
      tasks: Array.from(this.tasks.values()),
      executionOrder: this.calculateExecutionOrder(taskId),
      totalEstimatedDuration: this.calculateTotalDuration(taskId),
      createdAt: new Date(),
      status: 'created'
    };

    // „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„Å´‰øùÂ≠ò
    await this.sessionManager.saveProgress({
      totalTasks: executionPlan.tasks.length,
      completedTasks: 0,
      currentTaskIndex: 0,
      taskStatuses: executionPlan.tasks.map(task => ({
        id: task.id,
        name: task.name,
        status: task.status,
        startedAt: task.startedAt,
        completedAt: task.completedAt,
        error: task.error
      }))
    });

    logger.info(`ÂÆüË°å„Éó„É©„É≥‰ΩúÊàêÂÆå‰∫Ü: ${executionPlan.tasks.length}ÂÄã„ÅÆ„Çø„Çπ„ÇØ`);
    return executionPlan;
  }

  /**
   * LLM„Çí‰ΩøÁî®„Åó„ÅüÈ´òÂ∫¶„Å™„Çø„Çπ„ÇØÂàÜËß£
   */
  private async decomposeTaskWithLLM(mainTask: string): Promise<{
    subtasks: Array<{
      name: string;
      description: string;
      category: string;
      priority: number;
      estimatedMinutes: number;
      dependencies: string[];
      requiredTools: string[];
    }>;
    totalEstimatedTime: number;
    complexity: 'low' | 'medium' | 'high' | 'very_high';
  }> {
    // Êó¢Â≠ò„ÅÆAgentCore„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩøÁî®„Åó„Å¶LLMÂëº„Å≥Âá∫„Åó
    const agent = new (await import('./agent.js')).AgentCore(
      await import('../config/index.js').then(m => m.loadConfig()), 
      false
    );

    const decompositionPrompt = `
‰ª•‰∏ã„ÅÆ„É°„Ç§„É≥„Çø„Çπ„ÇØ„Çí„ÄÅÂÆüË°åÂèØËÉΩ„Å™Â∞è„Åï„Å™„Çµ„Éñ„Çø„Çπ„ÇØ„Å´ÂàÜËß£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„É°„Ç§„É≥„Çø„Çπ„ÇØ: "${mainTask}"

ÂàÜËß£„ÅÆÈöõ„ÅØ‰ª•‰∏ã„ÅÆË¶≥ÁÇπ„ÇíËÄÉÊÖÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
1. ÂêÑ„Çµ„Éñ„Çø„Çπ„ÇØ„ÅØÂÖ∑‰ΩìÁöÑ„ÅßÂÆüË°åÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®
2. ‰æùÂ≠òÈñ¢‰øÇ„ÇíÊòéÁ¢∫„Å´„Åô„Çã„Åì„Å®
3. ÊâÄË¶ÅÊôÇÈñì„ÇíÁèæÂÆüÁöÑ„Å´Ë¶ãÁ©ç„ÇÇ„Çã„Åì„Å®
4. ÂøÖË¶Å„Å™„ÉÑ„Éº„É´„ÇÑÊäÄË°ì„ÇíÁâπÂÆö„Åô„Çã„Åì„Å®
5. ÂÑ™ÂÖàÂ∫¶„ÇíÈÅ©Âàá„Å´Ë®≠ÂÆö„Åô„Çã„Åì„Å®

‰ª•‰∏ã„ÅÆÂΩ¢Âºè„ÅßJSON„Å®„Åó„Å¶ÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
{
  "subtasks": [
    {
      "name": "„Çµ„Éñ„Çø„Çπ„ÇØÂêç",
      "description": "Ë©≥Á¥∞„Å™Ë™¨Êòé",
      "category": "„Ç´„ÉÜ„Ç¥„É™Ôºà‰æãÔºöresearch, coding, testing, deploymentÔºâ",
      "priority": 1-10„ÅÆÊï∞ÂÄ§Ôºà10„ÅåÊúÄÈ´òÂÑ™ÂÖàÂ∫¶Ôºâ,
      "estimatedMinutes": Ë¶ãÁ©ç„ÇÇ„ÇäÊôÇÈñìÔºàÂàÜÔºâ,
      "dependencies": ["‰æùÂ≠ò„Åô„Çã„Çµ„Éñ„Çø„Çπ„ÇØÂêç„ÅÆÈÖçÂàó"],
      "requiredTools": ["ÂøÖË¶Å„Å™„ÉÑ„Éº„É´„ÅÆÈÖçÂàó"]
    }
  ],
  "totalEstimatedTime": ÂêàË®àË¶ãÁ©ç„ÇÇ„ÇäÊôÇÈñìÔºàÂàÜÔºâ,
  "complexity": "low | medium | high | very_high"
}`;

    const response = await agent.chat(decompositionPrompt);
    
    try {
      // JSON„É¨„Çπ„Éù„É≥„Çπ„ÇíËß£Êûê
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('JSONÂΩ¢Âºè„ÅÆÂøúÁ≠î„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
      }
      
      const result = JSON.parse(jsonMatch[0]);
      logger.debug('„Çø„Çπ„ÇØÂàÜËß£ÁµêÊûú:', result);
      
      return result;
    } catch (error) {
      logger.error('„Çø„Çπ„ÇØÂàÜËß£ÁµêÊûú„ÅÆËß£Êûê„Ç®„É©„Éº:', error);
      
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Ç∑„É≥„Éó„É´„Å™ÂàÜËß£
      return {
        subtasks: [
          {
            name: "Ë¶Å‰ª∂ÂàÜÊûê",
            description: "„Çø„Çπ„ÇØ„ÅÆË¶Å‰ª∂„Å®Âà∂Á¥Ñ„ÇíÂàÜÊûê",
            category: "research",
            priority: 9,
            estimatedMinutes: 15,
            dependencies: [],
            requiredTools: ["analysis"]
          },
          {
            name: "ÂÆüË£Ö",
            description: "„É°„Ç§„É≥„Çø„Çπ„ÇØ„ÅÆÂÆüË£Ö",
            category: "coding",
            priority: 8,
            estimatedMinutes: 60,
            dependencies: ["Ë¶Å‰ª∂ÂàÜÊûê"],
            requiredTools: ["coding", "tools"]
          },
          {
            name: "Ê§úË®º",
            description: "ÂÆüË£ÖÁµêÊûú„ÅÆÊ§úË®º",
            category: "testing",
            priority: 7,
            estimatedMinutes: 20,
            dependencies: ["ÂÆüË£Ö"],
            requiredTools: ["testing"]
          }
        ],
        totalEstimatedTime: 95,
        complexity: "medium"
      };
    }
  }

  /**
   * ÂÆüË°åÈ†ÜÂ∫è„ÇíË®àÁÆóÔºà‰æùÂ≠òÈñ¢‰øÇ„ÇíËÄÉÊÖÆÔºâ
   */
  private calculateExecutionOrder(rootTaskId: string): string[] {
    const visited = new Set<string>();
    const order: string[] = [];
    
    const visit = (taskId: string) => {
      if (visited.has(taskId)) return;
      
      const task = this.tasks.get(taskId);
      if (!task) return;
      
      visited.add(taskId);
      
      // ‰æùÂ≠òÈñ¢‰øÇ„ÇíÂÖà„Å´Âá¶ÁêÜ
      for (const depId of task.dependencies) {
        if (!visited.has(depId)) {
          visit(depId);
        }
      }
      
      // „Çµ„Éñ„Çø„Çπ„ÇØ„ÇíÂá¶ÁêÜ
      for (const subtaskId of task.subtasks) {
        visit(subtaskId);
      }
      
      if (taskId !== rootTaskId) {
        order.push(taskId);
      }
    };
    
    visit(rootTaskId);
    return order;
  }

  /**
   * ÂêàË®àÊâÄË¶ÅÊôÇÈñì„ÇíË®àÁÆó
   */
  private calculateTotalDuration(rootTaskId: string): number {
    const task = this.tasks.get(rootTaskId);
    if (!task) return 0;
    
    let total = task.estimatedDuration;
    for (const subtaskId of task.subtasks) {
      total += this.calculateTotalDuration(subtaskId);
    }
    
    return total;
  }

  /**
   * „Çø„Çπ„ÇØ„ÅÆÈñãÂßã
   */
  async startTask(taskId: string): Promise<void> {
    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`„Çø„Çπ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${taskId}`);
    }
    
    task.status = 'in_progress';
    task.startedAt = new Date();
    
    logger.info(`üîÑ „Çø„Çπ„ÇØÈñãÂßã: ${task.name}`);
    
    // ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
    await this.updateProgress();
  }

  /**
   * „Çø„Çπ„ÇØ„ÅÆÂÆå‰∫Ü
   */
  async completeTask(taskId: string, result?: any): Promise<void> {
    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`„Çø„Çπ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${taskId}`);
    }
    
    task.status = 'completed';
    task.completedAt = new Date();
    task.result = result;
    
    if (task.startedAt) {
      task.actualDuration = task.completedAt.getTime() - task.startedAt.getTime();
    }
    
    logger.info(`‚úÖ „Çø„Çπ„ÇØÂÆå‰∫Ü: ${task.name}`);
    
    // ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
    await this.updateProgress();
  }

  /**
   * „Çø„Çπ„ÇØ„ÅÆÂ§±Êïó
   */
  async failTask(taskId: string, error: string): Promise<void> {
    const task = this.tasks.get(taskId);
    if (!task) {
      throw new Error(`„Çø„Çπ„ÇØ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${taskId}`);
    }
    
    task.status = 'failed';
    task.completedAt = new Date();
    task.error = error;
    
    logger.error(`‚ùå „Çø„Çπ„ÇØÂ§±Êïó: ${task.name} - ${error}`);
    
    // ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
    await this.updateProgress();
  }

  /**
   * ÈÄ≤ÊçóÁä∂Ê≥Å„ÅÆÊõ¥Êñ∞
   */
  private async updateProgress(): Promise<void> {
    if (!this.currentRootTask) return;
    
    const allTasks = Array.from(this.tasks.values());
    const completedTasks = allTasks.filter(t => t.status === 'completed').length;
    const inProgressTasks = allTasks.filter(t => t.status === 'in_progress');
    const currentTaskIndex = inProgressTasks.length > 0 ? 
      allTasks.findIndex(t => t.id === inProgressTasks[0].id) : 0;
    
    await this.sessionManager.saveProgress({
      totalTasks: allTasks.length,
      completedTasks,
      currentTaskIndex,
      taskStatuses: allTasks.map(task => ({
        id: task.id,
        name: task.name,
        status: task.status,
        startedAt: task.startedAt,
        completedAt: task.completedAt,
        error: task.error
      }))
    });
  }

  /**
   * Ê¨°„Å´ÂÆüË°åÂèØËÉΩ„Å™„Çø„Çπ„ÇØ„ÇíÂèñÂæó
   */
  getNextExecutableTask(): TaskNode | null {
    for (const task of this.tasks.values()) {
      if (task.status === 'pending' && this.areDependenciesSatisfied(task)) {
        return task;
      }
    }
    return null;
  }

  /**
   * ‰æùÂ≠òÈñ¢‰øÇ„ÅåÊ∫Ä„Åü„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   */
  private areDependenciesSatisfied(task: TaskNode): boolean {
    return task.dependencies.every(depId => {
      const depTask = this.tasks.get(depId);
      return depTask?.status === 'completed';
    });
  }

  /**
   * ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÂèñÂæó
   */
  getProgress(): TaskProgress {
    const allTasks = Array.from(this.tasks.values());
    const completed = allTasks.filter(t => t.status === 'completed').length;
    const inProgress = allTasks.filter(t => t.status === 'in_progress').length;
    const failed = allTasks.filter(t => t.status === 'failed').length;
    const pending = allTasks.filter(t => t.status === 'pending').length;
    
    const totalEstimated = allTasks.reduce((sum, t) => sum + t.estimatedDuration, 0);
    const actualSpent = allTasks
      .filter(t => t.actualDuration)
      .reduce((sum, t) => sum + t.actualDuration!, 0);
    
    return {
      totalTasks: allTasks.length,
      completedTasks: completed,
      inProgressTasks: inProgress,
      failedTasks: failed,
      pendingTasks: pending,
      completionPercentage: Math.round((completed / allTasks.length) * 100),
      estimatedTotalDuration: totalEstimated,
      actualDuration: actualSpent,
      currentTask: allTasks.find(t => t.status === 'in_progress')?.name || null
    };
  }

  /**
   * „Çø„Çπ„ÇØIDÁîüÊàê
   */
  private generateTaskId(): string {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„Çí‰øùÂ≠ò
   */
  async saveSession(): Promise<void> {
    await this.sessionManager.saveSessionState({
      currentTask: this.currentRootTask || undefined,
      variables: new Map(Object.entries({
        tasks: Object.fromEntries(this.tasks),
        currentRootTask: this.currentRootTask
      })),
      metadata: {
        totalTasks: this.tasks.size,
        progress: this.getProgress()
      }
    });
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÇíË™≠„ÅøËæº„Åø
   */
  async loadSession(): Promise<void> {
    const state = await this.sessionManager.loadSessionState();
    
    if (state.variables) {
      const variables = state.variables as Map<string, any>;
      const tasksData = variables.get('tasks');
      const rootTaskData = variables.get('currentRootTask');
      
      if (tasksData) {
        this.tasks = new Map(Object.entries(tasksData));
      }
      
      if (rootTaskData) {
        this.currentRootTask = rootTaskData;
      }
    }
  }
}

/**
 * Á∂ôÁ∂öÂÆüË°å„Ç®„É≥„Ç∏„É≥ - ÂÖ®Ê©üËÉΩ„ÇíÁµ±Âêà„Åô„Çã„Éû„Çπ„Çø„Éº„ÇØ„É©„Çπ
 * „Äå‰∏Ä„Å§„ÅÆ„Éó„É≠„É≥„Éó„Éà„Åß„Ç¢„Éó„É™„ÇíÊúÄÂæå„Åæ„ÅßÂÆåÊàê„Åï„Åõ„Çã„Äç„É°„Ç§„É≥„Ç®„É≥„Ç∏„É≥
 */
export class ContinuousExecutionEngine {
  private agent: AgentCore;
  private reactController: ReActController;
  private taskManager: ContinuousTaskManager;
  private sessionManager: SessionStateManager;
  
  private isRunning: boolean = false;
  private isPaused: boolean = false;
  private currentExecutionPlan: ExecutionPlan | null = null;
  
  constructor(agent: AgentCore, sessionId?: string) {
    this.agent = agent;
    this.reactController = new ReActController(this.agent, 30); // ÊúÄÂ§ß30Âõû„ÅÆÂèçÂæ©
    this.taskManager = new ContinuousTaskManager(sessionId);
    this.sessionManager = new SessionStateManager(sessionId);
    
    logger.info('üöÄ Á∂ôÁ∂öÂÆüË°å„Ç®„É≥„Ç∏„É≥ÂàùÊúüÂåñÂÆå‰∫Ü');
  }

  /**
   * „É°„Ç§„É≥ÂÆüË°å„É°„ÇΩ„ÉÉ„Éâ - ÂÆå‰∫Ü„Åæ„ÅßÁ∂ôÁ∂öÂÆüË°å
   */
  async executeUntilComplete(
    userPrompt: string,
    options: {
      requireUserApproval?: boolean;
      maxExecutionTime?: number; // ÂàÜ
      allowManualIntervention?: boolean;
      planOnly?: boolean; // „Éó„É©„É≥„ÅÆ„Åø‰ΩúÊàê„Åó„Å¶ÂÆüË°å„ÅØÊâãÂãï
    } = {}
  ): Promise<ContinuousExecutionResult> {
    logger.info(`üéØ Á∂ôÁ∂öÂÆüË°åÈñãÂßã: "${userPrompt}"`);
    
    const startTime = Date.now();
    const maxTime = (options.maxExecutionTime || 120) * 60 * 1000; // „Éá„Éï„Ç©„É´„Éà2ÊôÇÈñì
    
    try {
      this.isRunning = true;
      
      // Phase 1: „Çª„ÉÉ„Ç∑„Éß„É≥ÂàùÊúüÂåñ
      await this.sessionManager.saveSessionInfo({
        startedAt: new Date(),
        initialPrompt: userPrompt,
        config: options
      });

      // Phase 2: „Çø„Çπ„ÇØÂàÜËß£„Å®ÂÆüË°å„Éó„É©„É≥‰ΩúÊàê
      logger.info('üìã ÂÆüË°å„Éó„É©„É≥‰ΩúÊàê‰∏≠...');
      this.currentExecutionPlan = await this.taskManager.createExecutionPlan(userPrompt);
      
      logger.info(`üìä ÂÆüË°å„Éó„É©„É≥ÂÆåÊàê: ${this.currentExecutionPlan.tasks.length}ÂÄã„ÅÆ„Çø„Çπ„ÇØ`);
      console.log('\n=== ÂÆüË°å„Éó„É©„É≥ ===');
      this.currentExecutionPlan.tasks.forEach((task, index) => {
        console.log(`${index + 1}. ${task.name} (ÂÑ™ÂÖàÂ∫¶: ${task.priority}, Ë¶ãÁ©ç: ${task.estimatedDuration}ÂàÜ)`);
      });
      
      // „Éó„É©„É≥„ÅÆ„Åø„ÅÆÂ†¥Âêà„ÅØÂÆüË°å„Åõ„ÅöÁµÇ‰∫Ü
      if (options.planOnly) {
        return {
          success: true,
          completed: false,
          finalResult: 'ÂÆüË°å„Éó„É©„É≥„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇÊâãÂãï„ÅßÂÆüË°å„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
          executionPlan: this.currentExecutionPlan,
          totalDuration: 0,
          tasksCompleted: 0,
          tasksTotal: this.currentExecutionPlan.tasks.length
        };
      }

      // Phase 3: „É¶„Éº„Ç∂„ÉºÊâøË™çÔºàÂøÖË¶Å„Å™Â†¥ÂêàÔºâ
      if (options.requireUserApproval) {
        console.log('\n‚ö†Ô∏è  ÂÆüË°åÊâøË™çÂæÖ„Å°: ‰∏äË®ò„ÅÆ„Éó„É©„É≥„ÅßÂÆüË°å„ÇíÈñãÂßã„Åó„Åæ„Åô„ÅãÔºü (y/n)');
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„ÄÅCLIÂÖ•ÂäõÂæÖ„Å°„Åæ„Åü„ÅØHTTP„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÁµåÁî±„Åß„ÅÆÊâøË™çÂæÖ„Å°
        // „Åì„Åì„Åß„ÅØËá™Âãï„ÅßÊâøË™ç„Åï„Çå„Åü„ÇÇ„ÅÆ„Å®„Åó„Å¶ÈÄ≤Ë°å
        logger.info('‚úÖ ÂÆüË°åÊâøË™çÊ∏à„ÅøÔºàËá™ÂãïÔºâ');
      }

      // Phase 4: ReActÁ∂ôÁ∂öÂÆüË°å
      logger.info('üîÑ ReActÁ∂ôÁ∂öÂÆüË°åÈñãÂßã...');
      
      const reactResult = await this.reactController.executeUntilComplete(
        userPrompt,
        (history) => {
          // „Ç´„Çπ„Çø„É†ÂÆå‰∫ÜÂà§ÂÆöÔºö„Åô„Åπ„Å¶„ÅÆ„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü„Åó„Åü„Åã
          return this.isExecutionComplete();
        }
      );

      // Phase 5: ÁµêÊûú„Å®„Çä„Åæ„Å®„ÇÅ
      const endTime = Date.now();
      const totalDuration = endTime - startTime;
      const progress = this.taskManager.getProgress();

      const result: ContinuousExecutionResult = {
        success: reactResult.success,
        completed: this.isExecutionComplete(),
        finalResult: reactResult.finalResult,
        executionPlan: this.currentExecutionPlan,
        reactHistory: reactResult.history,
        totalDuration: Math.round(totalDuration / 1000 / 60), // ÂàÜ
        tasksCompleted: progress.completedTasks,
        tasksTotal: progress.totalTasks,
        completionReason: reactResult.completionReason,
        performance: {
          iterations: reactResult.iterations,
          averageIterationTime: totalDuration / reactResult.iterations,
          taskCompletionRate: progress.completionPercentage
        }
      };

      // Phase 6: „Çª„ÉÉ„Ç∑„Éß„É≥ÂÆå‰∫ÜÂá¶ÁêÜ
      await this.finalizExecution(result);

      logger.info(`üèÅ Á∂ôÁ∂öÂÆüË°åÂÆå‰∫Ü: ${result.tasksCompleted}/${result.tasksTotal}„Çø„Çπ„ÇØ (${result.totalDuration}ÂàÜ)`);
      
      return result;

    } catch (error) {
      logger.error('Á∂ôÁ∂öÂÆüË°å„Ç®„É©„Éº:', error);
      
      return {
        success: false,
        completed: false,
        finalResult: `ÂÆüË°å„Ç®„É©„Éº: ${error instanceof Error ? error.message : String(error)}`,
        executionPlan: this.currentExecutionPlan,
        totalDuration: Math.round((Date.now() - startTime) / 1000 / 60),
        tasksCompleted: this.taskManager.getProgress().completedTasks,
        tasksTotal: this.taskManager.getProgress().totalTasks,
        error: error instanceof Error ? error.message : String(error)
      };
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * ÂÆüË°å„ÅÆ‰∏ÄÊôÇÂÅúÊ≠¢
   */
  async pauseExecution(): Promise<void> {
    if (!this.isRunning) {
      throw new Error('ÂÆüË°å‰∏≠„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì');
    }
    
    this.isPaused = true;
    logger.info('‚è∏Ô∏è  ÂÆüË°å„Çí‰∏ÄÊôÇÂÅúÊ≠¢„Åó„Åæ„Åó„Åü');
    
    // ÁèæÂú®„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
    await this.taskManager.saveSession();
  }

  /**
   * ÂÆüË°å„ÅÆÂÜçÈñã
   */
  async resumeExecution(): Promise<void> {
    if (!this.isPaused) {
      throw new Error('‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì');
    }
    
    this.isPaused = false;
    logger.info('‚ñ∂Ô∏è  ÂÆüË°å„ÇíÂÜçÈñã„Åó„Åæ„Åó„Åü');
  }

  /**
   * ÊâãÂãï„Åß„ÅÆ„Çø„Çπ„ÇØÂÆå‰∫Ü„Éû„Éº„ÇØ
   */
  async markTaskCompleted(taskId: string, result?: any): Promise<void> {
    await this.taskManager.completeTask(taskId, result);
    logger.info(`‚úÖ ÊâãÂãï„Çø„Çπ„ÇØÂÆå‰∫Ü: ${taskId}`);
  }

  /**
   * ÂÆüË°åÁä∂Ê≥Å„ÅÆÁõ£Ë¶ñ
   */
  getExecutionStatus(): ExecutionStatus {
    const progress = this.taskManager.getProgress();
    
    return {
      isRunning: this.isRunning,
      isPaused: this.isPaused,
      currentTask: progress.currentTask,
      progress: progress,
      reactProgress: this.reactController.getProgress(),
      sessionId: this.sessionManager.getSessionId()
    };
  }

  /**
   * ÂÆüË°åÂÆå‰∫ÜÂà§ÂÆö
   */
  private isExecutionComplete(): boolean {
    const progress = this.taskManager.getProgress();
    
    // ÂÖ®„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü„ÄÅ„Åæ„Åü„ÅØÈáçË¶Å„Çø„Çπ„ÇØ„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Çå„Å∞ÂÆå‰∫Ü„Å®„Åø„Å™„Åô
    const allTasksCompleted = progress.completedTasks >= progress.totalTasks;
    const criticalTasksCompleted = progress.completionPercentage >= 90; // 90%‰ª•‰∏ä„ÅßÂÆå‰∫Ü„Å®„Åô„Çã
    
    return allTasksCompleted || criticalTasksCompleted;
  }

  /**
   * ÂÆüË°å„ÅÆÊúÄÁµÇÂá¶ÁêÜ
   */
  private async finalizExecution(result: ContinuousExecutionResult): Promise<void> {
    try {
      // GitÊìç‰ΩúÔºà„Ç≥„Éü„ÉÉ„Éà & „Éó„ÉÉ„Ç∑„É•Ôºâ
      if (result.success && result.completed) {
        logger.info('üìù Â§âÊõ¥„Çí„Ç≥„Éü„ÉÉ„Éà„Åó„Å¶„ÅÑ„Åæ„Åô...');
        
        // ÂÆüË£ÖÂÆå‰∫Ü„Çí„Ç≥„Éü„ÉÉ„Éà
        // „Åì„ÅÆÈÉ®ÂàÜ„ÅØÂÆüÈöõ„ÅÆGitÊìç‰Ωú„ÇíË°å„ÅÜ
        // ÁèæÂú®„ÅØÊ¶ÇÂøµÁöÑ„Å™ÂÆüË£Ö
        logger.info('‚úÖ „Ç≥„Éü„ÉÉ„ÉàÂÆå‰∫Ü');
      }

      // „Çª„ÉÉ„Ç∑„Éß„É≥ÊúÄÁµÇÁä∂ÊÖã„Çí‰øùÂ≠ò
      await this.sessionManager.saveSessionState({
        currentTask: 'COMPLETED',
        metadata: {
          result,
          finalizedAt: new Date().toISOString()
        }
      });

      // ÂÆüË°å„É¨„Éù„Éº„Éà‰ΩúÊàê
      await this.generateExecutionReport(result);

    } catch (error) {
      logger.error('ÊúÄÁµÇÂá¶ÁêÜ„Ç®„É©„Éº:', error);
    }
  }

  /**
   * ÂÆüË°å„É¨„Éù„Éº„ÉàÁîüÊàê
   */
  private async generateExecutionReport(result: ContinuousExecutionResult): Promise<void> {
    const report = `
# Á∂ôÁ∂öÂÆüË°å„É¨„Éù„Éº„Éà

## ÂÆüË°åÊ¶ÇË¶Å
- ÈñãÂßãÊôÇÂàª: ${new Date().toISOString()}
- Á∑èÂÆüË°åÊôÇÈñì: ${result.totalDuration}ÂàÜ
- ÂÆå‰∫ÜÁä∂Ê≥Å: ${result.tasksCompleted}/${result.tasksTotal}„Çø„Çπ„ÇØ (${Math.round((result.tasksCompleted / result.tasksTotal) * 100)}%)
- ÊúÄÁµÇÁµêÊûú: ${result.success ? 'ÊàêÂäü' : 'Â§±Êïó'}

## „Çø„Çπ„ÇØË©≥Á¥∞
${result.executionPlan?.tasks.map((task, index) => 
  `${index + 1}. ${task.name} - ${task.status}`
).join('\n') || 'Ë©≥Á¥∞„Å™„Åó'}

## „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ
- ReActÂèçÂæ©ÂõûÊï∞: ${result.performance?.iterations || 0}
- Âπ≥ÂùáÂèçÂæ©ÊôÇÈñì: ${result.performance?.averageIterationTime ? Math.round(result.performance.averageIterationTime / 1000) : 0}Áßí

## ÊúÄÁµÇÂá∫Âäõ
${result.finalResult}
`;

    // ‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„Å´„É¨„Éù„Éº„Éà‰øùÂ≠ò
    await this.sessionManager.saveVirtualFile(
      'execution-report.md',
      report,
      { type: 'execution-report', generatedAt: new Date().toISOString() }
    );

    logger.info('üìä ÂÆüË°å„É¨„Éù„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü');
  }

  /**
   * „Çª„ÉÉ„Ç∑„Éß„É≥„Åã„Çâ„ÅÆÂæ©Êóß
   */
  async restoreFromSession(sessionId: string): Promise<void> {
    this.sessionManager = new SessionStateManager(sessionId);
    this.taskManager = new ContinuousTaskManager(sessionId);
    
    await this.taskManager.loadSession();
    
    logger.info(`üîÑ „Çª„ÉÉ„Ç∑„Éß„É≥Âæ©ÊóßÂÆå‰∫Ü: ${sessionId}`);
  }
}

/**
 * Á∂ôÁ∂öÂÆüË°åÁµêÊûú
 */
interface ContinuousExecutionResult {
  success: boolean;
  completed: boolean;
  finalResult: string;
  executionPlan: ExecutionPlan | null;
  reactHistory?: any[];
  totalDuration: number; // ÂàÜ
  tasksCompleted: number;
  tasksTotal: number;
  completionReason?: 'success' | 'max_iterations' | 'error' | 'user_requested';
  error?: string;
  performance?: {
    iterations: number;
    averageIterationTime: number;
    taskCompletionRate: number;
  };
}

/**
 * ÂÆüË°åÁä∂Ê≥Å
 */
interface ExecutionStatus {
  isRunning: boolean;
  isPaused: boolean;
  currentTask: string | null;
  progress: TaskProgress;
  reactProgress: any;
  sessionId: string;
}

/**
 * „Çø„Çπ„ÇØ„Éé„Éº„ÉâÔºàÂÆüË°åÂçò‰ΩçÔºâ
 */
interface TaskNode {
  id: string;
  name: string;
  description: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped';
  subtasks: string[];
  dependencies: string[];
  priority: number;
  estimatedDuration: number; // ÂàÜ
  actualDuration?: number; // „Éü„É™Áßí
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  result?: any;
  error?: string;
  metadata: Record<string, any>;
}

/**
 * ÂÆüË°å„Éó„É©„É≥
 */
interface ExecutionPlan {
  id: string;
  rootTaskId: string;
  tasks: TaskNode[];
  executionOrder: string[];
  totalEstimatedDuration: number;
  createdAt: Date;
  status: 'created' | 'in_progress' | 'completed' | 'failed' | 'paused';
}

/**
 * ÈÄ≤ÊçóÁä∂Ê≥Å
 */
interface TaskProgress {
  totalTasks: number;
  completedTasks: number;
  inProgressTasks: number;
  failedTasks: number;
  pendingTasks: number;
  completionPercentage: number;
  estimatedTotalDuration: number;
  actualDuration: number;
  currentTask: string | null;
}

// ContinuousExecutionEngine„ÇíAgentCore„ÅÆstatic„Éó„É≠„Éë„ÉÜ„Ç£„Å®„Åó„Å¶„Ç®„ÇØ„Çπ„Éù„Éº„Éà
(AgentCore as any).ContinuousExecutionEngine = ContinuousExecutionEngine;
